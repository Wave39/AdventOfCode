# 2015
## Status

| Day | Status | Execution Time | Hall of Shame |
| :---: | :---: | :---: | :--- |
| 1 | :smile: | <1s |
| 2 | :smile: | <1s |
| 3 | :smile: | <1s |
| 4 | :fire: | 1m 58s |
| 5 | :smile: | <1s |
| 6 | :warning: | 21s |
| 7 | :smile: | <1s |
| 8 | :smile: | <1s |
| 9 | :smile: | 3s |
| 10 | :smile: | 2s |
| 11 | :eyes: | 11s |
| 12 | :smile: | <1s |
| 13 | :fire: | 1m 34s |
| 14 | :smile: | <1s |
| 15 | :smile: | 1s |
| 16 | :smile: | <1s |
| 17 | :eyes: | 16s |
| 18 | :warning: | 21s |
| 19 | :smile: | 4s |
| 20 | :eyes: | 16s | The original solution that I had for this day was wildly inefficient, and when I tried to get it working here in Swift 5, I let it run for like 8 hours and it still did not finish day 1. As a result, I decided to seek a better solution, which I found on the internet. The algorithm I found has been implemented here and credit for the URL given at the top of the code. |
| 21 | :smile: | <1s |
| 22 | :smile: | <1s |
| 23 | :smile: | <1s |
| 24 | :smile: | <1s |
| 25 | :eyes: | 12s |

### Legend

| Status | Time for solution | Next steps |
| :---: | :---: | :--- |
| :smile: | 0..<10 seconds | All good here! |
| :eyes: | 10..<20 seconds | Could use some tidying up... |
| :warning: | 20..<60 seconds | Investigation is warranted. |
| :fire: | 60... seconds | It was a bad call, Ripley. |
